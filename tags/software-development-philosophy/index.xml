<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>software-development-philosophy on</title><link>https://doks.netlify.app/tags/software-development-philosophy/</link><description>Recent content in software-development-philosophy on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 11 Nov 2022 22:18:56 +0900</lastBuildDate><atom:link href="https://doks.netlify.app/tags/software-development-philosophy/index.xml" rel="self" type="application/rss+xml"/><item><title>Dependency inversion principle</title><link>https://doks.netlify.app/docs/philosophy/oop/dependency-inversion-principle/</link><pubDate>Fri, 11 Nov 2022 22:18:56 +0900</pubDate><guid>https://doks.netlify.app/docs/philosophy/oop/dependency-inversion-principle/</guid><description/></item><item><title>Interface segregation principle</title><link>https://doks.netlify.app/docs/philosophy/oop/interface-segregation-principle/</link><pubDate>Fri, 11 Nov 2022 22:18:48 +0900</pubDate><guid>https://doks.netlify.app/docs/philosophy/oop/interface-segregation-principle/</guid><description/></item><item><title>Liskov substitution principle</title><link>https://doks.netlify.app/docs/philosophy/oop/liskov-substitution-principle/</link><pubDate>Fri, 11 Nov 2022 22:18:40 +0900</pubDate><guid>https://doks.netlify.app/docs/philosophy/oop/liskov-substitution-principle/</guid><description/></item><item><title>Open-closed principle</title><link>https://doks.netlify.app/docs/philosophy/oop/open-closed-principle/</link><pubDate>Fri, 11 Nov 2022 22:18:30 +0900</pubDate><guid>https://doks.netlify.app/docs/philosophy/oop/open-closed-principle/</guid><description/></item><item><title>Single responsibility principle</title><link>https://doks.netlify.app/docs/philosophy/oop/single-responsibility-principle/</link><pubDate>Fri, 11 Nov 2022 22:09:05 +0900</pubDate><guid>https://doks.netlify.app/docs/philosophy/oop/single-responsibility-principle/</guid><description>Single responsibility principle imples &amp;ldquo;A class should have only one reason to change&amp;rdquo;. If a class has more than one responsibility, then the responsibilities become coupled. Breaking them into multiple classes could make you to think about more flexible code structure.
I personally think &amp;lsquo;one responsibility&amp;rsquo; is quite ambiguous. Too many things being handled in a single class is a generally bad idea if you consider flexibility, But spreading micro-sized classes all over the place could be a bad idea too.</description></item><item><title>SOLID</title><link>https://doks.netlify.app/docs/philosophy/oop/solid/</link><pubDate>Fri, 28 Oct 2022 00:16:11 +0900</pubDate><guid>https://doks.netlify.app/docs/philosophy/oop/solid/</guid><description>SOLID is acronym for five principles to write more maintainable code in object oriented programming.
Single responsibility principle Open-closed principle Liskov substitution principle Interface segregation principle Dependency inversion principle</description></item></channel></rss>